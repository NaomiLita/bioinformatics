"""
1. Take an arbitrary DNA sequence from the NCBI (National Center for Biotechnology), between 1000 and 3000 nucleotides (letters).
2. Take 2000 random samples from this sequence, of about 100-150 bases.
3. Store these samples in an array.
4. Rebuild the original DNA sequence using these random samples.
What would be the main problem with the algorithm approach? Describe.
Note: What kind of struct inside the original sequence may create different computation issues?
Note: The samples must be aligned starting with the min of the 10 positions in order. Avoid random matchings.
"""
import random


dna ="TCAATTATATTCAGCATGGAAAGAATAAAAGAACTACGGAATCTAATGTCGCAGTCTCGCACCCGCGAGATACTAACAAAAACCACAGTGGACCATATGGCCATAATTAAGAAGTACACATCGGGGAGACAGGAAAAGAACCCGTCACTTAGAATGAAATGGATGATGGCAATGAAATATCCAATTACTGCTGACAAAAGGATAACAGAAATGGTTCCAGAGAGAAATGAACAAGGACAAACCCTATGGAGTAAAATGAGTGATGCTGGGTCAGATAGAGTGATGGTATCACCTTTGGCTGTAACATGGTGGAATAGAAATGGGCCCGTGACAAATACGGTCCATTACCCAAAAGTGTACAAAACTTATTTTGACAAAGTCGAAAGGTTGAAACATGGAACCTTCGGCCCTGTCCATTTTAGAAACCAAGTCAAAATACGTAGAAGAGTAGACACAAACCCTGGTCATGCAGACCTCAGTGCCAAAGAGGCACAAGATGTAATTATGGAAGTTGTTTTTCCCAATGAAGTGGGGGCCAGAATACTAACATCAGAATCACAGCTAACAATAACCAAAGAGAAAAAAGAAGAACTCCGAGATTGCAAAATTTCCCCCTTGATGGTCGCATACATGCTAGAGAGAGAACTTGTGCGGAAAACAAGATTTCTCCCAGTTGCTGGCGGAACAAGCAGTATATACATTGAAGTTTTACATTTGACTCAAGGAACGTGTTGGGAACAAATGTACACTCCAGGTGGAGGAGTGAGGAATGACGATGTTGACCAAAGCCTAATTATTGCGGCCAGGAACATAGTGAGAAGAGCCGCAGTGTCAGCAGATCCACTCGCATCTTTATTGGAGATGTGCCACAGCACGCAAATTGGCGGAACAAGGATGGTGGACATTCTTAGGCAGAACCCGACTGAAGAACAAGCTGTGGATATATGCAAAGCTGCAATGGGATTGAGAATCAGCTCATCTTTCAGCTTTGGTGGCTTTACATTTAAAAGAACGAGCGGGTCGTCAGTCAAAAGAGATGAAGAGGTTCTTACAGGTAATCTCCAAACATTGAGAATAAGAGTACATGAGGGGTATGAGGAATTCACAATGGTGGGGAAAAGAGCAACAGCTATACTAAGAAAAGCAACCAGAAGACTGGTTCAACTCATAGTGAGTGGAAGAGACGAACAGTCAGTAGCCGAGGCAATAATCGTGGCCATGGTTTTTTCCCAAGAAGATTGCATGATAAAAGCAGTTAGAGGTGACCTGAATTTTGTCAACAGAGCAAATCAGCGGTTGAACCCCATGCATCAGCTTTTAAGGCATTTTCAGAAAGATGCGAAAGTACTCTTTCAAAATTGGGGAGTTGAACACATCGACAGTGTGATGGGAATGGTTGGAGTATTACCAGATATGACTCCAAGCACAGAGATGTCAATGAGAGGAATAAGAGTCAGCAAAATGGGCGTGGATGAATACTCCAGTACAGAGAGGGTGGTGGTTAGCATTGATAGGTTTTTGAGAGTTCGAGACCAACGGGGGAATGTATTGTTATCTCCTGAGGAAGTCAGTGAAACACAAGGAACTGAAAGACTGACCATAACTTATTCATCATCGATGATGTGGGAAATTAATGGGCCTGAGTCGGTTTTGGTCAATACCTATCAATGGATCATCAGGAATTGGGAAGCTATCAAAATTCAGTGGTCTCAGAACCCTGCAATGTTGTACAACAAAATGGAATTTGAACCATTTCAATCTTTAGTCCCCAAGGCCACTAGAAGCCAATACAGTGGGTTTGTCAGAACTCTATTCCAACAAATGAGAGACGTACTTGGGACATTTGACACTGCCCAGATAATAAAGCTTCTCCCTTTTGCAGCTGCTCCACCAAAGCAAAGCAGAATGCAGTTCTCTTCACTGACTGTGAATGTGAGGGGATCAGGGATGAGAATACTTGTAAGGGGCAATTCTCCTGTATTCAACTACAACAAGACCACTAAAAGGCTAACAATTCTTGGAAAAGATGCCGGCACTTTAATTGAAGACCCAGATGAAAGCACATCCGGAGTGGAGTCCGCCGTCTTGAGAGGGTTCCTCATTATAGGTAAAGAAGACAGAAGATACGGACCAGCATTAAGCATCAATGAACTGAGTAACCTTGCAAAAGGGGAAAAGGCTAATGTGTTAATTGGGCAAGGAGACGTGGTGTTGGTAATGAAACGGAAACGGGACTCTAGTATACTTACTGACAGCCAGACAGCGACCAAACGAATTCGGATGGCCATCAATTAATATTGAATAGTTTAAAAACGA"



num_samples = 2000
min_len = 100
max_len = 150
seq_length = len(dna)

seqs = []
for _ in range(num_samples):
    length = random.randint(min_len, max_len)
    start = random.randint(0, seq_length - length)
    sequence = dna[start:start + length]
    seqs.append(sequence)

print(f"Original DNA length: {seq_length}")
print(f"Number of samples: {len(seqs)}")
print(f"Example sample: {seqs[0]}")


#starting with the first ftagment
reconstructed = seqs[0]

#keeping track of used fragments to avoid reusing them!!!
used = {0}

# Function to find the next fragment with a strong overlap
def find_best_overlap(current_seq, fragments, used_indices):
    best_overlap = 0
    best_fragment = None
    best_index = None

    for i, frag in enumerate(fragments):
        if i in used_indices:
            continue

        for j in range(100, 10, -1):
            if current_seq.endswith(frag[:j]):
                if j > best_overlap:
                    best_overlap = j
                    best_fragment = frag
                    best_index = i          
    return best_fragment, best_index, best_overlap

while True:
    next_frag, next_idx, overlap = find_best_overlap(reconstructed, seqs, used)
    if next_frag is None or overlap < 10:
        break  # Stop if no suitable overlap found
    reconstructed += next_frag[overlap:]
    used.add(next_idx)

#accuracy as a percentage of correctly matched bases
match_len = 0
for i in range(min(len(dna), len(reconstructed))):
    if dna[i] == reconstructed[i]:
        match_len += 1

accuracy = (match_len / len(dna)) * 100

print(f"Reconstructed length: {len(reconstructed)}")
print(f"Reconstruction accuracy: {accuracy:.2f}%")
